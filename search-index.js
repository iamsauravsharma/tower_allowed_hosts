var searchIndex = new Map(JSON.parse('[\
["tower_allowed_hosts",{"doc":"Crate which provides allowed hosts layer for tower based …","t":"FFNNNNNNNNNCNNNNNCNNNNNNNNGPPNNNNNNNNNNFFFNNNNNNNNNNNNNNNNNNNNNNNNNNN","n":["AllowedHostLayer","Host","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","default","error","from","from","into","into","layer","service","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","Error","FailedToResolveHost","HostNotAllowed","borrow","borrow_mut","fmt","fmt","from","into","to_string","try_from","try_into","type_id","AllowedHost","AllowedHostFuture","AllowedHostLayer","borrow","borrow","borrow_mut","borrow_mut","call","clone","clone_into","extend","extend_regex","extend_wildcard","from","from","into","into","into_future","poll","poll_ready","set_reject_multiple_hosts","set_use_forwarded","set_use_x_forwarded_host","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"tower_allowed_hosts"],[26,"tower_allowed_hosts::error"],[39,"tower_allowed_hosts::service"],[69,"core::result"],[70,"core::any"],[71,"core::fmt"],[72,"core::fmt"],[73,"http::request"],[74,"http::response"],[75,"tower_service"],[76,"core::clone"],[77,"core::convert"],[78,"core::iter::traits::collect"],[79,"regex::regex::string"],[80,"core::pin"],[81,"core::task::wake"],[82,"core::task::poll"],[83,"tower"],[84,"core::future::future"]],"d":["Allowed hosts layer to check if provided host is valid or …","Struct which holds value of host along with its port if …","","","","","","","","","","module for error","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","module for layer, service and future","","","","","","","","","Enum for different error generated from crates","error when host is failed to resolve","error raised when host is not allowed","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","Allowed hosts service","Future for Allowed hosts","Allowed hosts layer to check if provided host is valid or …","","","","","","","","Extend allowed hosts list using normal string. To match …","Extend allowed hosts list using regex. Regex is check to …","Extend allowed hosts list using wildcard.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Reject request is one header have multiple host. For …","Set <code>use_forwarded</code> to provided value. If it is set to true …","Set <code>use_x_forwarded_host</code> to provided value. If it is set …","","","","","","",""],"i":[0,0,1,2,1,2,1,2,1,2,1,0,1,2,1,2,1,0,1,2,1,2,1,2,1,2,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,10,20,10,20,10,10,10,1,1,1,10,20,10,20,20,20,10,1,1,1,10,10,20,10,20,10,20],"f":"``{ce{}{}}000{bb}{dd}{{ce}f{}{}}0{{}b}`{cc{}}055{{bc}e{}{}}`66{c{{h{e}}}{}{}}000{cj{}}0```88{{ln}A`}049{cAb{}}332```::::{{{Ad{g}}{Af{c}}}i{}{}{{Al{{Af{c}}}{{Ah{{Aj{e}}}}}}}{}}{{{Ad{c}}}{{Ad{c}}}An}9{{be}b{{B`{Ab}}}{{Bd{}{{Bb{c}}}}}}{{bc}b{{Bd{}{{Bb{Bf}}}}}}199>>{c{}{}}{{{Bj{{Bh{g}}}}Bl}{{Bn{i}}}{}{{B`{C`}}}{{Cd{}{{Cb{{h{ce}}}}}}}{}}{{{Ad{g}}Bl}{{Bn{{h{fi}}}}}{}{}{{Al{{Af{c}}}{{Ah{{Aj{e}}}}}}}{}}{{bCf}b}00{ce{}{}}<<<<;;","c":[],"p":[[5,"AllowedHostLayer",0],[5,"Host",0],[1,"unit"],[6,"Result",69],[5,"TypeId",70],[6,"Error",26],[5,"Formatter",71],[8,"Result",71],[5,"String",72],[5,"AllowedHost",39],[5,"Request",73],[17,"Response"],[5,"Response",74],[10,"Service",75],[10,"Clone",76],[10,"Into",77],[17,"Item"],[10,"IntoIterator",78],[5,"Regex",79],[5,"AllowedHostFuture",39],[5,"Pin",80],[5,"Context",81],[6,"Poll",82],[8,"BoxError",83],[17,"Output"],[10,"Future",84],[1,"bool"]],"b":[[31,"impl-Debug-for-Error"],[32,"impl-Display-for-Error"]]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
